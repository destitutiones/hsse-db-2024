# Материалы

- [Лекция 7](https://drive.google.com/file/d/1NySY7H8nHOg7dHpZx1-zyo3WU-XF7q4z/view?usp=sharing)
- Документация по
  [view](https://postgrespro.ru/docs/postgresql/14/sql-createview)

# Теория

## View

**Представление (view)** – это виртуальная таблица, содержимое которой (столбцы
и строки) определяется запросом.

**Свойства view:**

- Не является самостоятельной частью набора данных
- Вычисляется динамически на основании данных, хранящихся в реальных таблицах
- Изменение данных в таблицах немедленно отражается в содержимом представлений

Представление можно использовать в следующих целях:

- Для направления, упрощения и настройки восприятия информации в базе данных
  каждым пользователем.
- В качестве механизма безопасности, позволяющего пользователям обращаться к
  данным через представления, но не дающего им разрешений на непосредственный
  доступ к базовым таблицам.

**Достоинства:**

- _Безопасность:_ можно искусственно ограничивать информацию, к которой у
  пользователя есть доступ.
- _Простота запросов:_ при написании запросов обращаемся к вью, как и к обычной
  таблице.
- _Защита от изменений:_ пользователю не обязательно знать, что структуры /
  имена таблиц поменялись. Достаточно обновить представление.

**Недостатки:**

- _Производительность:_ кажущийся простым запрос с использованием вью на деле
  может оказаться очень сложным из-за логики, “зашитой” во вью.
- _Управляемость:_ вью может быть основана на вью, которая в свою очередь тоже
  основана на другой вью и т.д.

**Синтаксис:**

```sql
CREATE
[ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ]
  VIEW name [ ( column_name [, ...] ) ]
  [
WITH (view_option_name [= view_option_value] [, ...]) ]
  AS query
  [
WITH [ CASCADED | LOCAL ] CHECK
OPTION ]
```

- `CREATE VIEW` – создание нового представления.
- `CREATE OR REPLACE VIEW` – создание или замена уже существующего
  представления.
  - В случае замены в новом представлении должны присутствовать все поля старого
    представления (имена, порядок, тип данных). Допустимо только добавление
    новых полей.
- `TEMPORARY | TEMP` – временное представление, будет существовать до конца
  сессии.
- _view_name_ – название представления.
- _column_name_ – список полей представления. Если не указан, используются поля
  запроса.
- _query_ – `SELECT` или `VALUES` команды.

[Изменения представления](https://www.postgresql.org/docs/current/sql-alterview.html):

```sql
ALTER VIEW [IF EXISTS] name ALTER [COLUMN] column_name SET DEFAULT
expression
ALTER VIEW [IF EXISTS] name ALTER [COLUMN] column_name DROP DEFAULT
ALTER VIEW [IF EXISTS] name OWNER TO new_owner
ALTER VIEW [IF EXISTS] name RENAME TO new_name
ALTER VIEW [IF EXISTS] name SET SCHEMA new_schema
ALTER VIEW [IF EXISTS] name SET ( view_option_name [=
view_option_value] [, ... ] )
ALTER VIEW [IF EXISTS] name RESET ( view_option_name [, ... ] )
DROP VIEW [IF EXISTS] name [, ...] [ CASCADE | RESTRICT ]
```

Примеры:

1. Создание представления

```sql
CREATE VIEW greeting AS
SELECT 'Hello World';

CREATE VIEW greeting AS
SELECT text 'Hello World' AS hello;


CREATE VIEW comedy AS
SELECT
    *
FROM
    films
WHERE
    kind = 'Comedy';
```

Если после создания представления добавить столбцы в таблицу, в представлении их
не будет.

 <details>
   <summary>Почему так?</summary>

При парсинге запроса при создании view `*` преобразуется в перечисление всех
имеющихся на момент создания колонок отношения.

 </details>

**TEMP или TEMPORARY**

Представление создаётся как временное. Удаляется при окончании сессии

```sql
CREATE TEMP VIEW greeting AS
SELECT 'Hello World';
```

**RECURSIVE**

Представление создаётся как рекурсивное. Эквивалентные формы:

```sql
CREATE RECURSIVE VIEW [ schema. ] view_name (column_names) AS
SELECT ...;
```

```sql
CREATE VIEW [ schema.] view_name AS
WITH RECURSIVE view_name (column_names) AS (SELECT ...)
SELECT column_names
FROM view_name;
```

**Пример рекурсивного представления:**

```sql
CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
VALUES (1)
UNION ALL
SELECT
    n + 1
FROM
    nums_1_100
WHERE
    n < 100;
```

**Типы представлений:**

1. _горизонтальное_ — ограничение данных по строкам:

```sql
CREATE VIEW V_IT_EMPLOYEE AS
SELECT
    *
FROM
    EMPLOYEE
WHERE
    DEPARTMENT_NM = 'IT';
```

2. _вертикальное_ — ограничение данных по столбцам:

```sql
CREATE VIEW V_EMP AS
SELECT
    EMP_NM,
    DEPARTMENT_NM
FROM
    EMPLOYEE;
```

**Обновляемые представления**

Представление называется _обновляемым_, если к нему применимы операции `UPDATE`
и `DELETE` для изменения данных в таблицах, на которых построено это
представление.

**Требования:**

- Ровно 1 источник в предложении `FROM`, являющийся таблицей или обновляемым
  представлением
- Запрос не должен содержать `WITH`, `DISTINCT`, `GROUP BY`, `HAVING`, `LIMIT`
  или `OFFSET`
- Запрос не должен содержать операторов `UNION`, `INTERSECT` или `EXCEPT`
- select-list запроса не должен содержать агрегатных, оконных, а также функций,
  возвращающих множества.

```postgresql
WITH [ CASCADED | LOCAL ] CHECK
OPTION
```

Задаёт поведение обновляемым представлениям: проверки, не позволяющие записывать
данные, невидимые через представление

- `LOCAL` – проверки выполняются только на самом представлении
- `CASCADED` – проверки выполняются и на самом представлении, и на источнике, и
  так далее по цепочке обращений

Обновляемые представления – пример 1:

```postgresql
CREATE VIEW universal_comedy AS
SELECT
    *
FROM
    comedy
WHERE
    classification = 'U'
WITH LOCAL CHECK OPTION;
```

Попытка вставить или отредактировать ряд с `classification <> 'U'` приведёт к
ошибке. \
Но при этом вставка или редактирование ряда с `kind <> 'Comedy'` будет успешной.

Обновляемые представления – пример 2:

```postgresql
CREATE VIEW universal_comedies AS
SELECT
    *
FROM
    comedy
WHERE
    classification = 'U'
WITH CASCADED CHECK OPTION;
```

Попытка вставить или отредактировать ряд с classification <> 'U' или kind <>
'Comedy' приведёт к ошибке.

Столбцы в обновляемом представлении могут быть как обновляемые, так и не
обновляемые.

Обновляемые представления – пример 3:

```postgresql
CREATE VIEW comedy AS
SELECT
    f.*,
    country_code_to_name(f.country_code) AS country,
    (SELECT avg(r.rating) FROM user_ratings r WHERE r.film_id = f.id) AS avg_rating
FROM
    films f
WHERE
    f.kind = 'Comedy';
```

Все столбцы таблицы `films` – обновляемые. Столбцы `country` и `avg_rating` –
`readonly`.

Если представление не удаётся сделать обновляемым, но в этом есть потребность –
используйте `INSTEAD OF` триггер.

Это такая функция, которая будет обрабатывать операции модификации данных –
рассмотрим позже.

## План выполнения запроса

### Жизненный цикл запроса, план запроса.

_Мы написали запрос, что происходит дальше?_

1. Создается **подключение к СУБД**. В СУБД отправляется запрос в виде обычного
   текста.
2. Парсер **проверяет корректность синтаксиса** и создает **дерево запроса**.
3. Система переписывания запросов преобразует запрос – получаем обновленное
   дерево запроса; используется
   [система правил](https://translated.turbopages.org/proxy_u/en-ru.ru.fff4fecf-62668e84-a3814da0-74722d776562/https/www.postgresql.org/docs/8/rules.html))
4. Планировщик / оптимизатор создает **план запроса**.
5. Обработчик рекурсивно обходит план запроса и получает результирующий набор
   строк.

**Дерево запроса** — специальное внутреннее представление SQL-запросов с полным
его разбором по ключевым параметрам:

- Тип команды (`SELECT, UPDATE, DELETE, INSERT`);
- Список используемых отношений;
- Целевое отношение, в которое будет записан результат;
- Список полей (`*` преобразуется в полный список всех полей);
- Список ограничений (которые указаны в `WHERE`);
- и т.д.

### План запроса. Как читать, на что обращать внимание. Операторы EXPLAIN и ANALYZE.

**Планировщик (planner)** – компонент PostgreSQL, пытающийся выработать наиболее
эффективный способ выполнения запроса SQL.

В плане выполнения содержится информация о том, как будет организован просмотр
таблиц, задействованных в запросе, сервером базы данных.

Оператор [EXPLAIN](https://postgrespro.com/docs/postgresql/9.6/sql-explain):

**Функции:**

- Выводит план выполнения, генерируемый планировщиком PostgreSQL для заданного
  оператора.
- Показывает, как будут сканироваться таблицы, затрагиваемые оператором — просто
  последовательно, по индексу и т.д.
- Показывает, какой алгоритм соединения будет выбран для объединения считанных
  из таблиц строк.
- Показывает ожидаемую _стоимость_ (в условных единицах) выполнения запроса.
- ОТСУТСТВУЕТ в стандарте SQL.

**Синтаксис:**

```sql
EXPLAIN [ ( option [, ...] ) ] statement
EXPLAIN [ ANALYZE ] [ VERBOSE ] statement

where option can be one of:
ANALYZE [ boolean ]
VERBOSE [ boolean ]
COSTS [ boolean ]
BUFFERS [ boolean ]
TIMING [ boolean ]
FORMAT { TEXT | XML | JSON | YAML }
```

```sql
    INSERT INTO my_table ...;
    EXPLAIN SELECT * FROM my_table;
- - - -
QUERY PLAN
Seq Scan on my_table (cost=0.00..18334.00 rows=1000000 width=37)
```

**Что это значит?**

- Данные читаются методом Seq Scan из таблицы my_table
- `cost` — затраты (в некоторых условных единицах) на получение первой
  строки..всех строк
- `rows` — приблизительное количество возвращаемых строк при выполнении операции
  Seq Scan (никакие строки не вычитываются, значение приблизительное)
- `width` — средний размер одной строки в байтах

При повторном вызове покажет старую статистику, необходимо вызвать команду
ANALYZE для ее обновления.

Оператор [ANALYZE](https://postgrespro.ru/docs/postgresql/9.6/sql-analyze):

**Функции:**

- Собирает статистическую информацию о содержимом таблиц в базе данных и
  сохраняет результаты в системном каталоге `pg_statistic`;
- Без параметров анализирует все таблицы в текущей базе данных.
- Если в параметрах передано имя таблицы, обрабатывает только заданную таблицу.
- Если в параметрах передан список имен столбцов, то сбор статистики запустится
  только по этим столбцам.
- ОТСУТСТВУЕТ в стандарте SQL.

**Синтаксис:**

```sql
ANALYZE [ VERBOSE ] [ table_name [ ( column_name [, ...] ) ] ]
```

```sql
ANALYZE my_table;
EXPLAIN SELECT * FROM my_table;

EXPLAIN (ANALYZE) SELECT * FROM my_table;
- - - -
QUERY PLAN
Seq Scan on foo (cost=0.00..18334.10 rows=1000010 width=37)
(actual time=0.402..97.000 rows=1000010 loops=1)

Planning time: 0.042 ms
Execution time: 138.229 ms
```

Теперь запрос будет исполняться реально.

- `actual time` — реальное время в миллисекундах, затраченное для получения
  первой строки и всех строк соответственно.
- `rows` — реальное количество строк, полученных при Seq Scan.
- `loops` — сколько раз пришлось выполнить операцию Seq Scan.
- `Planning time` — время, потраченное планировщиком на построение плана
  запроса.
- `Execution time` — общее время выполнения запроса.

Оператор [VACUUM](https://postgrespro.ru/docs/postgrespro/9.5/sql-vacuum):

Отвечает за "сборку мусора" и возможно сопутствующий анализ БД.

```sql
VACUUM [ ( { FULL | FREEZE | VERBOSE | ANALYZE } [, ...] ) ] [ имя_таблицы [ (имя_столбца [, ...] ) ] ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ имя_таблицы ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] ANALYZE [ имя_таблицы [ (имя_столбца [, ...] ) ] ]
```

`VACUUM` высвобождает пространство, занимаемое «мёртвыми» кортежами. При обычных
операциях Postgres кортежи, удалённые или устаревшие в результате обновления,
физически не удаляются из таблицы; они сохраняются в ней, пока не будет
выполнена команда VACUUM. Таким образом, периодически необходимо выполнять
`VACUUM`, особенно для часто изменяемых таблиц.

### Индексы. Определение, условия использования.

**Индекс** — специальный объект БД, хранящийся отдельно от таблиц и
обеспечивающий быстрый доступ к данным. Это вспомогательные структуры: любой
индекс можно удалить и восстановить заново по информации в таблице. Индексы
служат также для поддержки некоторых ограничений целостности.

В PostgreSQL 9.6 встроены _шесть разных видов индексов_.

**Свойства:**

- Все индексы — вторичные, они отделены от таблицы. Вся информация о них
  содержится в системном каталоге.
- При добавлении/изменении данных, связанных с индексом, индекс каждый раз
  перестраивается (это замедляет выполнение запроса).
- Внутри могут лежать разные математические структуры (B-дерево, черно-красное
  дерево...)
- Индексы могут быть многоколоночными (поддержание условия на несколько полей).
- Индексы связывают ключи и TID (tuple id - #page: #offset) — номер страницы и
  строки на ней.
- Обновление полей таблицы, по которым не создавались индексы, не приводит к
  перестроению индексов (Heap-Only Tuples, HOT).

_Оптимизация HOT:_ при апдейте строки, если это возможно, Postgres поставит
новую копию строки сразу после старой копии строки. Также в старой копии строки
проставляется специальная метка, указывающая на то, что новая копия строки
находится сразу после старой. Поэтому обновлять все индексы не нужно.

**Условия использования:**

- Совпадают оператор и типы аргументов.
- Индекс валиден.
- Важен порядок полей внутри многоколоночного индекса, чтобы накладывать
  условия, ожидая, что оптимизатор выберет индекс.
- План с его использованием — оптимален (минимальная стоимость).
- Всю информацию Postgres берет из системного каталога.

**Синтаксис:**

```sql
CREATE [UNIQUE] INDEX [CONCURRENTLY] [name] ON table_name [USING METHOD]...
CREATE INDEX ON my_table(column_2);
ALTER INDEX [IF EXISTS] name RENAME TO new_name
DROP INDEX [CONCURRENTLY] [IF EXISTS] name [, ...] [CASCADE|RESTRICT]

ALTER INDEX [IF EXISTS] name RENAME TO new_name
ALTER INDEX [IF EXISTS] name SET TABLESPACE tablespace_name
ALTER INDEX [IF EXISTS] name SET (storage_parameter = value [, ... ])
ALTER INDEX [IF EXISTS] name RESET (storage_parameter [, ... ])
DROP INDEX [CONCURRENTLY] [IF EXISTS] name [, ...] [CASCADE|RESTRICT]
```

**Общая информация**

- Индексы работают тем лучше, чем выше селективность условия, то есть чем меньше
  строк ему удовлетворяет. При увеличении выборки возрастают и накладные расходы
  на чтение страниц индекса.
- Ситуация усугубляется тем, что последовательное чтение выполняется быстрее,
  чем чтение страниц «вразнобой». Это особенно верно для жестких дисков, где
  механическая операция подведения головки к дорожке занимает существенно больше
  времени, чем само чтение данных; в случае дисков SSD этот эффект менее
  выражен.

### Способы считывания данных

**Seq Scan**

**Идея:** Последовательное, блок за блоком, чтение данных таблицы.

**Преимущества:** При большом объеме данных для одного значения индексного поля,
работает эффективнее индексного сканирования, так как обычно оно работает с
большими блоками данных, поэтому за одну операцию доступа потенциально может
выбрать большее количество данных, чем индексное сканирование, соответственно,
нужно меньше операций доступа, скорость выше.

**Недостатки:** Обычно выполняется гораздо медленнее индексного сканирования,
так как считывает все данные таблицы.

**Index Scan**

**Идея:** Используется индекс для условий `WHERE` (селективность условия),
читает таблицу при отборе строк.

**Преимущества:** При селективности условия время N → lnN. (В результате
выполнения запроса выбирается значительно меньше строк, чем их кол-во в
странице)

**Недостатки:** Если будем собирать индекс по всем полям, он будет весить
зачастую значительно больше, чем данные в таблице. При увеличении выборки
возрастают шансы, что придется возвращаться к одной и той же табличной странице
несколько раз. (В таком случае оптимизатор переключается на Bitmap Scan)

**Bitmap Index Scan**

**Идея:** Сначала Index Scan, затем контроль выборки по таблице. В большей части
работа со строками (индекс по строке, битовая карта страниц, последующий отбор)

**Преимущества:** Эффективно для большого количества строк.

**Недостатки:** Не ускоряет работу, если условие не является селективным.
Выборка может оказаться слишком велика для объема оперативной памяти, тогда
строится только битовая карта страниц — она занимает меньше места, но при чтении
страницы приходится перепроверять условия для каждой хранящейся там строки.

- В случае почти упорядоченных данных построение битовой карты — лишний шаг,
  обычное индексное сканирование будет таким же.
- Создается битовая карта, где предполагаем, что в соответствии с собранной
  статистикой наши строки удовлетворяют нашему условию; в ней есть странички;
- Если условия наложены на несколько полей таблицы, и эти поля проиндексированы,
  сканирование битовой карты позволяет (если оптимизатор сочтет это выгодным)
  использовать несколько индексов одновременно. Для каждого индекса строятся
  битовые карты версий строк, которые затем побитово логически умножаются (если
  выражения соединены условием AND), либо логически складываются (если выражения
  соединены условием OR).

**Index Only Scan**

**Идея:** Практически не обращаемся к таблице, все необходимые значения в
индексе.

**Преимущества:** Очень быстрая операция.

**Недостатки:** Может применяться только тогда, когда индекс включает все
необходимые для выборки поля, и дополнительный доступ к таблице не требуется.

Если индекс уже содержит все необходимые для запроса данные, то индекс
называется _покрывающим_.

---

# Практика

## View

Будем работать с таблицами `seminar_7.film` и `seminar_7.film_translation`.

1. Создать view – полную копию таблицы `seminar_7.film`;
2. Создать view – копию таблицы `seminar_7.film` для фильмов, которые
   представлены на двух или более языках.
3. Создать view с полным списком фильмов и колонкой-списком языков, на которые
   он переведен. Не добавляйте колонку `code`.
4. Создать view со статисткой по жанрам: для каждого жанра выведите количество
   фильмов этого типа в таблице `seminar_7.film`, а также дату выхода самого
   раннего фильма такого типа.
5. Написать вставку записи (на своё усмотрение) во view из пункта (1).
   Проверить, что новая запись появилась в исходной таблице;
6. Написать удаление записи, вставленной в пункте (5), через view из пункта (1).
   Проверить, что запись удалилась из исходной таблицы;
7. Обновить дату выхода фильма с `code='00008'` на '1995-05-01' через view из
   пункта (1);
8. Удалить информацию о переводах фильма с `code='00008'` и убедиться, что фильм
   пропал из view из пункта (2);
9. Пересоздать view и пункта (2) с условием [with local check option].
   Попробовать проделать те же манипуляции, что в пункте (8) на фильме
   `code='00010'`.

## План выполнения запроса.

Напишем несколько запросов к таблице
[pg_class](https://postgrespro.ru/docs/postgresql/9.6/catalog-pg-class).

1. Выведем план запроса по выводу всех строк таблицы `pg_class`. Запустим с
   флагом `ANALYZE` – поменялось ли что-то?
2. Запустим тот же запрос с `limit 2`. Как поменялся план запроса?
3. Рассмотрим строки, относящиеся к объектам, содержащим букву 'a' в названии
   (поле `relname`).
4. Построим план запроса для вывода строк с полем `oid`, имеющим значение 1247.
   Обратите внимание на тип сканирования таблицы.
5. Попробуем в запросе отсортировать таблицу по полю `oid` и вывести топ-10
   строк. Попробуйте отсортировать в обратном порядке – что-то поменялось?
6. Создадим следующую таблицу:

```sql
create table seminar_7.test (id serial primary key, i int4);

insert into seminar_7.test (i)
select random() * 1000000000
from generate_series(1,100000);
```

Какими значениями мы её заполнили? Выведем план следующего запроса: выберем из
таблицы топ-10 строк в порядке возрастания поля id. Поменяется ли что-то в
случае сортировки по убыванию?

7. Отберите все строки из таблицы `seminar_7.test` с `i < 100000`. Выведите план
   этого запроса, какой метод считывания используется? Попробуйте добавить новый
   индекс поверх поля `i` и перезапустите запрос. Поменялся ли метод считывания?
   Попробуйте поменять условие на следующее: `i < 5000000 or i > 950000000`.
